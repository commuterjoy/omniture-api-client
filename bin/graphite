#!/usr/bin/ruby 

require 'lib/omniture'
require 'lib/graphite'
require 'trollop'
require 'date'
require 'json'

args = Trollop::options do
    opt :host,        "Graphite host - Eg. graphite.guprod.gnl",                                 :type => :string
    opt :path,        "Prefix for all your metrics",                                             :type => :string
    opt :buffer,      "Number of hours buffer you want to wait for Omniture to report the data", :type => :int, :default => 6 
    opt :data,        "Data link names",                                                         :type => :string
    opt :kpis,        "Log page views / visitors / visits",                                      :type => :boolean
    opt :from,        "From (days)",                                                             :type => :int, :default => 30 
    opt :to,          "To (days)",                                                               :type => :int, :default => 0
    opt :granularity, "Granularity",                                                             :type => :string, :default => 'day'
    opt :segment,     "Segment",                                                                 :type => :string 
end

# ---

def days_from_today(n)
    (Date.today - n).strftime('%Y-%m-%d') 
end

# ---

def generate_report(from, to, granularity, evars, segment)

   Report.new().queueTrended(
    {
      :from => days_from_today(from),
      :to => days_from_today(to),
      :segment => segment,
      :metric => "event37",
      :element_id => "evar37",
      :granularity => granularity,
      :evars => evars
    })

end

# ---

def generate_kpi_report(from, granularity, segment)

    Report.new().queueQueueOvertime(
      {
        :date => days_from_today(from),
        :metrics => ['pageViews', 'visits', 'visitors'],
        :granularity => granularity,
        :segment => segment,
      })

end

# ---

def log_to_graphite(report_id, args)

    graphite = Graphite.new({
            :host => args[:host],
            :verbose => true
        })

    report = Report.new().to_ganglia(report_id, args[:buffer])

    # modify the array 
    if args[:kpis]
        report['metrics'] = report['metrics'].pop(3)
    end

    report['metrics'].each { |metric|

        path = [
            args[:path].split('.'),
            'omniture',
            'v003',
        ]

        if args[:data]
            path.push(args[:data])
        end

        path.push(metric[:title].split("|").map{|m|m.gsub(/[\s]/,'')}.join('-').downcase)

        if args[:segment]
            path.push(args[:segment].gsub(/[ ], '-'/)) 
        end

        puts "#{path.inspect}"

        graphite.log({
                :path => path.join('.'),
                :value => metric[:breakdown][:value],
                :time => metric[:breakdown][:time].to_i
        })
    }

end

# ---

def has_report_finished(id)
    
    report = Report.new().getReportQueue()
    JSON.parse(report).map { |item|
        item['report_id'].to_i
    }.include? id
    
end

# ---


if args[:kpis]
    report = generate_kpi_report(args[:from], args[:granularity], args[:segment])
else
    report = generate_report(args[:from], args[:to], args[:granularity], args[:data].split(","), args[:segment])
end

report_as_json = JSON.parse(report)

unless report_as_json['statusMsg'] == 'Your report has been queued' 
    puts report.inspect
    raise "Report did not generate"
    exit 1
end

report_id = report_as_json['reportID']

puts "report requested ... #{report_id}"

loop do
    break unless has_report_finished(report_id)
    sleep 5
end

puts "report generated ... #{report_id}"

log_to_graphite(report_id, args)
:w

